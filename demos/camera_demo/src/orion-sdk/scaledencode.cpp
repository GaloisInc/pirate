// scaledencode.c was generated by ProtoGen version 2.12.c

#include "scaledencode.hpp"
#include "fieldencode.hpp"


/*!
 * Scale a float32 to the base integer type used for bitfield
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the integer.
 * \return (value-min)*scaler.
 */
unsigned int float32ScaledToBitfield(float value, float min, float scaler)
{
    // Protect from underflow, overflow must be handled by caller
    if(value < min)
        return 0;

    // scale the number
    value = (value - min)*scaler;

    // account for fractional truncation
    return (unsigned int)(value + 0.5f);
}


/*!
 * Scale a float64 to the base integer type used for bitfield
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the integer.
 * \return (value-min)*scaler.
 */
unsigned int float64ScaledToBitfield(double value, double min, double scaler)
{
    // Protect from underflow, overflow must be handled by caller
    if(value < min)
        return 0;

    // scale the number
    value = (value - min)*scaler;

    // account for fractional truncation
    return (unsigned int)(value + 0.5);
}

#ifdef UINT64_MAX

/*!
 * Scale a float32 to the base integer type used for long bitfields
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the integer.
 * \return (value-min)*scaler.
 */
uint64_t float32ScaledToLongBitfield(float value, float min, float scaler)
{
    // Protect from underflow, overflow must be handled by caller
    if(value < min)
        return 0;

    // scale the number
    value = (value - min)*scaler;

    // account for fractional truncation
    return (uint64_t)(value + 0.5f);
}


/*!
 * Scale a float64 to the base integer type used for long bitfields
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the integer.
 * \return (value-min)*scaler.
 */
uint64_t float64ScaledToLongBitfield(double value, double min, double scaler)
{
    // Protect from underflow, overflow must be handled by caller
    if(value < min)
        return 0;

    // scale the number
    value = (value - min)*scaler;

    // account for fractional truncation
    return (uint64_t)(value + 0.5);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 8 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo8UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 18446744073709551615ull))
        number = 18446744073709551615ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint64ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 8 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo8UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 18446744073709551615ull))
        number = 18446744073709551615ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint64ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 8 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo8SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 9223372036854775807ll))
            number = 9223372036854775807ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-9223372036854775807ll - 1)))
            number = (-9223372036854775807ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int64ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 8 signed bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo8SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 9223372036854775807ll))
            number = 9223372036854775807ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-9223372036854775807ll - 1)))
            number = (-9223372036854775807ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int64ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 7 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo7UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 72057594037927935ull))
        number = 72057594037927935ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint56ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 7 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo7UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 72057594037927935ull))
        number = 72057594037927935ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint56ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 7 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo7SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 36028797018963967ll))
            number = 36028797018963967ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-36028797018963967ll - 1)))
            number = (-36028797018963967ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int56ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 7 signed bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo7SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 36028797018963967ll))
            number = 36028797018963967ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-36028797018963967ll - 1)))
            number = (-36028797018963967ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int56ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 6 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo6UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 281474976710655ull))
        number = 281474976710655ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint48ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 6 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo6UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 281474976710655ull))
        number = 281474976710655ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint48ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 6 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo6SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 140737488355327ll))
            number = 140737488355327ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-140737488355327ll - 1)))
            number = (-140737488355327ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int48ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 6 signed bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo6SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 140737488355327ll))
            number = 140737488355327ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-140737488355327ll - 1)))
            number = (-140737488355327ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int48ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 5 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo5UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 1099511627775ull))
        number = 1099511627775ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint40ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 5 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo5UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 1099511627775ull))
        number = 1099511627775ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint40ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 5 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo5SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 549755813887ll))
            number = 549755813887ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-549755813887ll - 1)))
            number = (-549755813887ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int40ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 5 signed bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo5SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 549755813887ll))
            number = 549755813887ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-549755813887ll - 1)))
            number = (-549755813887ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int40ToLeBytes((int64_t)number, bytes, index);
}

#endif // UINT64_MAX

/*!
 * Encode a double on a byte stream by scaling to fit in 4 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo4UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 4294967295uL))
        number = 4294967295uL;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5); // account for fractional truncation

    uint32ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 4 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo4UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 4294967295uL))
        number = 4294967295uL;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5); // account for fractional truncation

    uint32ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 4 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo4SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 2147483647))
            number = 2147483647;
        else
            number = (int32_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-2147483647 - 1)))
            number = (-2147483647 - 1);
        else
            number = (int32_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int32ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 4 signed bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo4SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 2147483647))
            number = 2147483647;
        else
            number = (int32_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-2147483647 - 1)))
            number = (-2147483647 - 1);
        else
            number = (int32_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int32ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 3 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo3UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 16777215u))
        number = 16777215u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5); // account for fractional truncation

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 3 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo3UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 16777215u))
        number = 16777215u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5); // account for fractional truncation

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 3 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo3SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 8388607))
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-8388607 - 1)))
            number = (-8388607 - 1);
        else
            number = (int32_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 3 signed bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo3SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 8388607))
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-8388607 - 1)))
            number = (-8388607 - 1);
        else
            number = (int32_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 2 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo2UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 65535u))
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5); // account for fractional truncation

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 2 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo2UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 65535u))
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5); // account for fractional truncation

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 2 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo2SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 32767))
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-32767 - 1)))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 2 signed bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo2SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 32767))
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-32767 - 1)))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 1 unsigned byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo1UnsignedBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 255u))
        number = 255u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint8_t)(scaledvalue + 0.5); // account for fractional truncation

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a double on a byte stream by scaling to fit in 1 signed byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo1SignedBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 127))
            number = 127;
        else
            number = (int8_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-127 - 1)))
            number = (-127 - 1);
        else
            number = (int8_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 4 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo4UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 4294967295uL))
        number = 4294967295uL;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint32ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 4 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo4UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 4294967295uL))
        number = 4294967295uL;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint32ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 4 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo4SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 2147483647))
            number = 2147483647;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-2147483647 - 1)))
            number = (-2147483647 - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int32ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 4 signed bytes in little
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo4SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 2147483647))
            number = 2147483647;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-2147483647 - 1)))
            number = (-2147483647 - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int32ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 3 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo3UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 16777215u))
        number = 16777215u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 3 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo3UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 16777215u))
        number = 16777215u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 3 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo3SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 8388607))
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-8388607 - 1)))
            number = (-8388607 - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 3 signed bytes in little
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo3SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 8388607))
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-8388607 - 1)))
            number = (-8388607 - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 2 unsigned bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo2UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 65535u))
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 2 unsigned bytes in
 * little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo2UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 65535u))
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 2 signed bytes in big
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo2SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 32767))
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-32767 - 1)))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 2 signed bytes in little
 * endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo2SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 32767))
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-32767 - 1)))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 1 unsigned byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo1UnsignedBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= ((double) 255u))
        number = 255u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint8_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a float on a byte stream by scaling to fit in 1 signed byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo1SignedBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= ((double) 127))
            number = 127;
        else
            number = (int8_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= ((double) (-127 - 1)))
            number = (-127 - 1);
        else
            number = (int8_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int8ToBytes((int8_t)number, bytes, index);
}


// end of scaledencode.c
