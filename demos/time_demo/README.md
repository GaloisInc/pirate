# Trusted Timestamp Example

## Design Goals
 - Implement a design experiment that is well-suited for integrating and testing
   GAPS technology. Furthermore, this experiment will serve as a test ground for
   exploring potential not asked questions related to GAPS hardware and software
   behaviors.
 - Simplicity - the design and implementation will focus on experimenting and
   testing GAPS hardware channels and PIRATE source code annotations
 - Scalable to more than two sensitivity domains
 - Correct and stable implementation - before applying GAPS pirate annotations
   application binaries will be checked for runtime errors and memory leaks with
   Valgrind. This step is necessary for mitigating potential bugs or unintended
   behaviors that may be introduced by added compiler changes.  

## Overview
Trusted timestamping is the process of tracking the time that data was created
or modified. A trusted timestamp generally identifies:
 - Data to be timestamped (typically a secure hash of the data)
 - Time that the data was timestamped; provided by a trusted time source
 - Digital signature generated by a trusted third party

## Trusted Timestamp Example Design
For GAPS, we think an interesting scenario is one where the application contains
sensitive data that it needs signed, but at a minimum the signing service should
not be able to infer information about the data to sign. As many applications
may involve signing data regularly, this may include not leaking the timing of
when data changes necessitate a new signature, and whether two different
signature requests may reflect the same underlying data.

 ![Alt text](images/trusted_ts.png?raw=true "Trusted Timestamp Demo")

To account for these side channels, we propose a three component architecture
that inserts a proxy between the application and the signing service. The proxy
is responsible for regularly sending signature requests, and all communications
between the application and signing service go through the proxy. At a minimum,
the proxy should be separated from the signing service using a GAPS
channel, but there are significant security benefits if the proxy and
application are also separated by a GAPS channel.


## Time-Stamp Protocol
In order to leverage an exiting specifications and implementation of a trusted
timestamp protocol, the Time-Stamp Protocol (TSP) was chosen for this example.

[RFC3161](https://tools.ietf.org/html/rfc3161) defines TPS and required PKI
components.

OpenSSL provides support for TPS

Commands below exemplify how ```openssl ts``` may be used
```
$ openssl ts -query -config <config_file> -cert -data <input_data> -out <ts_query>
$ openssl ts -reply -config <config_file> -section  <tsa_section> -queryfile <ts_query> -out <tsr>
$ openssl ts -verify -config <config_file> -section <tsa_section> -CAfile <certificate_authority> -data <input_data> -in <tsr>
```
The GAPS Trusted Timestamp Demo leverages source code from OpenSSL source code
repository, in particular, from ```apps/ts.c```

## Building
All demo components are built by following instructions provided
[in the main project README](/README.md).
* The build process generates PKI components, which include creation of two
  private/public key pairs. On a machine with limited resources this step may
  take a noticeable amount of time.
* To build time demo with a single executable across enclaves, use ```cmake .. -DSINGLE_BINARY=ON```
* All build artifacts are located in ```build/time_demo``` directory

```
$ cd pirate
$ mkdir build
$ cd build
$ cmake -DGAPS_DEMOS=ON -DGAPS_DISABLE=ON ..
$ make
```

## Running

The default command-line options use paths relative to the directory
of the binary. The default PKI configuration files also use relative paths.
Run three terminals for each of the three executables.

```
cd build/demos/time_demo/purple
./signing_service -v \
  --proxy-to-signer="pipe,/tmp/proxy.signer.gaps" \
  --signer-to-proxy="pipe,/tmp/signer.proxy.gaps"
```

```
cd build/demos/time_demo/yellow
./signing_proxy -v \
  --client-to-proxy="pipe,/tmp/client.proxy.gaps" \
  --proxy-to-client="pipe,/tmp/proxy.client.gaps" \
  --signer-to-proxy="pipe,/tmp/signer.proxy.gaps" \
  --proxy-to-signer="pipe,/tmp/proxy.signer.gaps"
```

```
cd build/demos/time_demo/orange
./sensor_manager -v \
  --client-to-proxy="pipe,/tmp/client.proxy.gaps" \
  --proxy-to-client="pipe,/tmp/proxy.client.gaps"
```

The sensor manager will use the `/dev/video0` camera by default
as the input source. If the video device cannot be opened then
stock images will be used instead. Use the flag `-D [filepath]`
to specify a different video device.

![timestamp of stock image 1](/demos/time_demo/example1.jpg)

![timestamp of stock image 2](/demos/time_demo/example2.jpg)

Use the flag `-x` to run the sensor manager in headless mode.
The sensor manager in headless mode will use the stock images
as the input source. The images will not be displayed in
an X window.

### Dependencies
* [libpirate](/libpirate)
* [OpenSSL](https://www.openssl.org/)
* [Valgrind](https://valgrind.org/)

## Implementation
All three demo components are based on common code for configuring and managing
GAPS channels as well as work thread creation and termination. Sections of code
for GAPS channel management will be replaced with code generated by the
compiler when GAPS source annotations became available.

Timestamp cryptography code is based on OpenSSL's support for
[RFC3161](https://tools.ietf.org/html/rfc3161) Time-Stamp Protocol (TSP) and is
located in the ```ts_crypto.c``` source file. All data structures for storing
requests and responses are designed to be agnostic to cryptographic algorithms
behind the implementation.

### Verbosity
By default all demo components run in a quiet mode. Use ```-v``` to increase
output verbosity.
- ```-v``` displays event messages
- ```-v``` or ```-vv``` displays event messages and parsed request/response
 structure components. __NOTE__ this level of verbosity is mainly used for
 debugging.

### Usage
All application binaries support help and usage options:
- ```<application binary> --help```
- ```<application binary> --usage```

#### Sensor Manager (Trusted Timestamp Client)
```
Usage: sensor_manager [OPTION...] [FILE] [FILE] ...
Sign files with the trusted timestamp service

  -C, --ca_path=PATH         CA path
  -d, --req_delay=MS         Request delay in milliseconds
  -O, --save_path=PATH       TSR output directory
  -S, --cert_path=PATH       Signing certificate path
  -v, --verbose              Increase verbosity level
  -V, --verify               Verify timestamp signatures
  -?, --help                 Give this help list
      --usage                Give a short usage message
      --version              Print program version
```

#### Signing Proxy
```
Usage: signing_proxy [OPTION...]
Proxy between the client and timestamp signing service

  -p, --period=MS            Request polling period
  -q, --queue-len=LEN        Request queue length
  -v, --verbose              Increase verbosity level
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version
```

#### Trusted Timestamp Service
```
Usage: signing_service [OPTION...]
Timestamp signing service

  -c, --conf=PATH            Configuration file path
  -s, --conf_sect=SECTION    Configuration section
  -v, --verbose              Increase verbosity level
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version
```

#### Trusted Timestamp Cryptography Test
```
Usage: ts_test [OPTION...] [FILE] [FILE] ...
Generate TS request, TS sign, and TS validate test

  -c, --config=PATH          Configuration file
  -C, --ca_path=PATH         CA Path
  -n, --loops=ITERATIONS     Number of test iterations
  -s, --section=SECTION      Configuration TSA section
  -v, --verbosity            Increase verbosity level
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version
```

## Directory Structure

### Source, Configuration, and Scripts
The build processes copies configuration resources into appropriate output
build directories. An attempt to run scripts from the `scripts` directory will
likely result in an error.
```
time_demo
├── conf
│   └── OpenSSL configuration resources
├── include
│   └── Trusted Timestamp Demo headers
├── scripts
│   └── Test and launch scripts
└── src
    └── Trusted Timestamp Demo sources
```

### Output Directory
The output directory and its components are auto-generated by the build process.
```
time_demo
├── ca
│   └── .priv
│       └── tsa_ca_key.pem     Certificate authority private key
│── tsa
│   ├── tsa_ca.pem             Certificate authority signing certificate
│   └── tsa_cert.pem           Timestamp service certificate
├── orange
│   ├── .dev_id                'Device ID' for orange enclave
│   ├── sensor_manager         Timestamp client application binary
│   ├── ts_demo                Combined binary application
│   └── ts_verify.sh           Timestamp verification script
│── yellow
│   ├── .dev_id                'Device ID' for yellow enclave
│   ├── signing_proxy          Timestamp proxy application binary
│   └── ts_demo                Combined binary application
├── purple
│   ├── .dev_id                'Device ID' for purple enclave
│   ├── .priv
│   │   ├── tsa.conf           Timestamp service configuration file
│   │   ├── tsa_key.pem        Timestamp service private key
│   │   └── tsa_req.pem        Timestamp service CA sign request
│   ├── signing_service        Timestamp service application binary
│   └── ts_demo                Combined binary application
└── test
   ├── ts_test                 Timestamp cryptography unit test binary
   └── ts_test.sh              Timestamp cryptography memory test script            
```

## Testing
Trusted timestamp sequence of
```
[Proxy Request] -> [Timestamp Request] -> [Timestamp Sign] -> [Timestamp Verify]
```
is tested in a standalone application ```low/ts_test```.

```low/ts_test.sh``` script executes the test application under different levels of
verbosity and checks for memory leaks and errors.

## Setup

### Applying udev rules
In order to avoid ambiguity of ```/dev/ttyUSB*``` device assignment, a udev
rules file was added to generate symbolic links for pre-configured USB to serial
devices.
```
$ cd time_demo/scripts
$ ./add_udev_rules.sh
```
__NOTE__ ___sudo___ privileges are required for this task

### Adding a new USB serial device
Determine __vendor id__, __product id__, and __serial number__ of the device:
```
$ lsusb
...
Bus 001 Device 005: ID 0403:6001 Future Technology Devices International, Ltd FT232 USB-Serial (UART) IC
...

$ sudo lsusb -v -d 0403:6001 | grep iSerial
  iSerial                 3 AC018LUP
```
__NOTE__ The last command will run successfully without ___sudo___, however, the
serial number will not be fetched.

Add a new entry to the ```gaps.rules``` file
```
SUBSYSTEMS=="usb", KERNEL=="ttyUSB*", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6001", ATTRS{serial}=="AC018LUP", SYMLINK+="<name>"
```
Apply updated udev rules by following instructions in the section above

__NOTE__ not all USB to serial devices provide a valid serial number, however, [this](https://www.amazon.com/gp/product/B07589ZF9X/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1) device does.

### Add the current user to the __dialout__ group
```
$ sudo usermod -a -G dialout <user_name>
```
__NOTE__ technically this step is not needed as long as time demo binaries are
executed with ___sudo___ privileges.

### Serial Connection
A serial [null modem](https://en.wikipedia.org/wiki/Null_modem) is required.

## Troubleshooting
### GAPS Serial Device Fails to Open
* Verify that the symbolic link is present ```ls /dev/tty_*```
* Verify that the user has privileges to open the device

### Serial Data is Corrupted
* Unplug and plug back in USB to serial converters
* Run UART stress test located in ```build/time_demo/low```
* Reduce the baud rate. Note this change requires editing of ```libpirate/test/serial_test.c``` and re-compilation
* Use a different USB to serial device

### Time Signature Fails Validation
* Make sure that the time service is configured with proper PKI. This issue may occur when timestamp signing service was compiled independently on a separate machine. Instead of building time stamp service, copy ```pki``` and ```low``` directories to the target machine.
* Make sure that system time is set correctly.

## Outstanding Tasks
- Add and test GAPS annotations
- Add a worker thread in signing proxy for sending back client replies. This
  step may be needed to monotonize proxy to service request period if
  transmission of a timestamp response over a GAPS channel takes a measurable
  amount of time
- Improve unit tests by adding proper test build targets
